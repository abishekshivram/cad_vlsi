//
// Generated by Bluespec Compiler, version untagged-g5f8fb782 (build 5f8fb782)
//
// On Tue Dec  7 14:48:56 IST 2021
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkcheck(CLK,
	       RST_N);
  input  CLK;
  input  RST_N;

  // register check1
  reg [31 : 0] check1;
  wire [31 : 0] check1_D_IN;
  wire check1_EN;

  // register check2
  reg [31 : 0] check2;
  wire [31 : 0] check2_D_IN;
  wire check2_EN;

  // register counter
  reg [31 : 0] counter;
  wire [31 : 0] counter_D_IN;
  wire counter_EN;

  // ports of submodule router1
  wire [31 : 0] router1_get_valueVC1,
		router1_get_valueVC2,
		router1_get_valueVC3,
		router1_get_valueVC4,
		router1_get_valueVC5,
		router1_get_valueVC6,
		router1_put_value_flit;
  wire router1_EN_get_valueVC1,
       router1_EN_get_valueVC2,
       router1_EN_get_valueVC3,
       router1_EN_get_valueVC4,
       router1_EN_get_valueVC5,
       router1_EN_get_valueVC6,
       router1_EN_put_value,
       router1_RDY_get_valueVC1,
       router1_RDY_get_valueVC2,
       router1_RDY_get_valueVC3,
       router1_RDY_get_valueVC4,
       router1_RDY_get_valueVC5,
       router1_RDY_get_valueVC6,
       router1_RDY_put_value;

  // ports of submodule router2
  wire [31 : 0] router2_put_value_flit;
  wire router2_EN_get_valueVC1,
       router2_EN_get_valueVC2,
       router2_EN_get_valueVC3,
       router2_EN_get_valueVC4,
       router2_EN_get_valueVC5,
       router2_EN_get_valueVC6,
       router2_EN_put_value;

  // rule scheduling signals
  wire CAN_FIRE_RL_check1_update1,
       CAN_FIRE_RL_check1_update2,
       CAN_FIRE_RL_two_cycle1,
       CAN_FIRE_RL_two_cycle2,
       CAN_FIRE_RL_two_cycle3,
       CAN_FIRE_RL_two_cycle4,
       CAN_FIRE_RL_two_cycle5,
       CAN_FIRE_RL_two_cycle6,
       CAN_FIRE_RL_update_counter,
       WILL_FIRE_RL_check1_update1,
       WILL_FIRE_RL_check1_update2,
       WILL_FIRE_RL_two_cycle1,
       WILL_FIRE_RL_two_cycle2,
       WILL_FIRE_RL_two_cycle3,
       WILL_FIRE_RL_two_cycle4,
       WILL_FIRE_RL_two_cycle5,
       WILL_FIRE_RL_two_cycle6,
       WILL_FIRE_RL_update_counter;

  // remaining internal signals
  wire NOT_counter_SLT_2___d10;

  // submodule router1
  mkChainRouterVC #(.my_addr(32'd0)) router1(.CLK(CLK),
					     .RST_N(RST_N),
					     .put_value_flit(router1_put_value_flit),
					     .EN_put_value(router1_EN_put_value),
					     .EN_get_valueVC1(router1_EN_get_valueVC1),
					     .EN_get_valueVC2(router1_EN_get_valueVC2),
					     .EN_get_valueVC3(router1_EN_get_valueVC3),
					     .EN_get_valueVC4(router1_EN_get_valueVC4),
					     .EN_get_valueVC5(router1_EN_get_valueVC5),
					     .EN_get_valueVC6(router1_EN_get_valueVC6),
					     .RDY_put_value(router1_RDY_put_value),
					     .get_valueVC1(router1_get_valueVC1),
					     .RDY_get_valueVC1(router1_RDY_get_valueVC1),
					     .get_valueVC2(router1_get_valueVC2),
					     .RDY_get_valueVC2(router1_RDY_get_valueVC2),
					     .get_valueVC3(router1_get_valueVC3),
					     .RDY_get_valueVC3(router1_RDY_get_valueVC3),
					     .get_valueVC4(router1_get_valueVC4),
					     .RDY_get_valueVC4(router1_RDY_get_valueVC4),
					     .get_valueVC5(router1_get_valueVC5),
					     .RDY_get_valueVC5(router1_RDY_get_valueVC5),
					     .get_valueVC6(router1_get_valueVC6),
					     .RDY_get_valueVC6(router1_RDY_get_valueVC6));

  // submodule router2
  mkChainRouterVC #(.my_addr(32'd1)) router2(.CLK(CLK),
					     .RST_N(RST_N),
					     .put_value_flit(router2_put_value_flit),
					     .EN_put_value(router2_EN_put_value),
					     .EN_get_valueVC1(router2_EN_get_valueVC1),
					     .EN_get_valueVC2(router2_EN_get_valueVC2),
					     .EN_get_valueVC3(router2_EN_get_valueVC3),
					     .EN_get_valueVC4(router2_EN_get_valueVC4),
					     .EN_get_valueVC5(router2_EN_get_valueVC5),
					     .EN_get_valueVC6(router2_EN_get_valueVC6),
					     .RDY_put_value(),
					     .get_valueVC1(),
					     .RDY_get_valueVC1(),
					     .get_valueVC2(),
					     .RDY_get_valueVC2(),
					     .get_valueVC3(),
					     .RDY_get_valueVC3(),
					     .get_valueVC4(),
					     .RDY_get_valueVC4(),
					     .get_valueVC5(),
					     .RDY_get_valueVC5(),
					     .get_valueVC6(),
					     .RDY_get_valueVC6());

  // rule RL_check1_update1
  assign CAN_FIRE_RL_check1_update1 =
	     router1_RDY_put_value && counter == 32'd0 ;
  assign WILL_FIRE_RL_check1_update1 = CAN_FIRE_RL_check1_update1 ;

  // rule RL_check1_update2
  assign CAN_FIRE_RL_check1_update2 =
	     router1_RDY_put_value && counter == 32'd1 ;
  assign WILL_FIRE_RL_check1_update2 = CAN_FIRE_RL_check1_update2 ;

  // rule RL_two_cycle1
  assign CAN_FIRE_RL_two_cycle1 =
	     router1_RDY_get_valueVC1 && NOT_counter_SLT_2___d10 ;
  assign WILL_FIRE_RL_two_cycle1 = CAN_FIRE_RL_two_cycle1 ;

  // rule RL_two_cycle2
  assign CAN_FIRE_RL_two_cycle2 =
	     router1_RDY_get_valueVC2 && NOT_counter_SLT_2___d10 ;
  assign WILL_FIRE_RL_two_cycle2 = CAN_FIRE_RL_two_cycle2 ;

  // rule RL_two_cycle3
  assign CAN_FIRE_RL_two_cycle3 =
	     router1_RDY_get_valueVC3 && NOT_counter_SLT_2___d10 ;
  assign WILL_FIRE_RL_two_cycle3 = CAN_FIRE_RL_two_cycle3 ;

  // rule RL_two_cycle4
  assign CAN_FIRE_RL_two_cycle4 =
	     router1_RDY_get_valueVC4 && NOT_counter_SLT_2___d10 ;
  assign WILL_FIRE_RL_two_cycle4 = CAN_FIRE_RL_two_cycle4 ;

  // rule RL_two_cycle5
  assign CAN_FIRE_RL_two_cycle5 =
	     router1_RDY_get_valueVC5 && NOT_counter_SLT_2___d10 ;
  assign WILL_FIRE_RL_two_cycle5 = CAN_FIRE_RL_two_cycle5 ;

  // rule RL_two_cycle6
  assign CAN_FIRE_RL_two_cycle6 =
	     router1_RDY_get_valueVC6 && NOT_counter_SLT_2___d10 ;
  assign WILL_FIRE_RL_two_cycle6 = CAN_FIRE_RL_two_cycle6 ;

  // rule RL_update_counter
  assign CAN_FIRE_RL_update_counter = 1'd1 ;
  assign WILL_FIRE_RL_update_counter = 1'd1 ;

  // register check1
  assign check1_D_IN = 32'h0 ;
  assign check1_EN = 1'b0 ;

  // register check2
  assign check2_D_IN = 32'h0 ;
  assign check2_EN = 1'b0 ;

  // register counter
  assign counter_D_IN = counter + 32'd1 ;
  assign counter_EN = 1'd1 ;

  // submodule router1
  assign router1_put_value_flit =
	     WILL_FIRE_RL_check1_update2 ? 32'h80000000 : 32'hFFFFFFFF ;
  assign router1_EN_put_value =
	     WILL_FIRE_RL_check1_update2 || WILL_FIRE_RL_check1_update1 ;
  assign router1_EN_get_valueVC1 = CAN_FIRE_RL_two_cycle1 ;
  assign router1_EN_get_valueVC2 = CAN_FIRE_RL_two_cycle2 ;
  assign router1_EN_get_valueVC3 = CAN_FIRE_RL_two_cycle3 ;
  assign router1_EN_get_valueVC4 = CAN_FIRE_RL_two_cycle4 ;
  assign router1_EN_get_valueVC5 = CAN_FIRE_RL_two_cycle5 ;
  assign router1_EN_get_valueVC6 = CAN_FIRE_RL_two_cycle6 ;

  // submodule router2
  assign router2_put_value_flit = 32'h0 ;
  assign router2_EN_put_value = 1'b0 ;
  assign router2_EN_get_valueVC1 = 1'b0 ;
  assign router2_EN_get_valueVC2 = 1'b0 ;
  assign router2_EN_get_valueVC3 = 1'b0 ;
  assign router2_EN_get_valueVC4 = 1'b0 ;
  assign router2_EN_get_valueVC5 = 1'b0 ;
  assign router2_EN_get_valueVC6 = 1'b0 ;

  // remaining internal signals
  assign NOT_counter_SLT_2___d10 = (counter ^ 32'h80000000) >= 32'h80000002 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        check1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	check2 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	counter <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (check1_EN) check1 <= `BSV_ASSIGNMENT_DELAY check1_D_IN;
	if (check2_EN) check2 <= `BSV_ASSIGNMENT_DELAY check2_D_IN;
	if (counter_EN) counter <= `BSV_ASSIGNMENT_DELAY counter_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    check1 = 32'hAAAAAAAA;
    check2 = 32'hAAAAAAAA;
    counter = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_check1_update1) $display("put at 0");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_check1_update2) $display("put at 1");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_two_cycle1)
	$display("counter==%d, data=%h from VC1",
		 $signed(counter),
		 $signed(router1_get_valueVC1));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_two_cycle2)
	$display("counter==%d, data=%h from VC2",
		 $signed(counter),
		 $signed(router1_get_valueVC2));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_two_cycle3)
	$display("counter==%d, data=%h from VC3",
		 $signed(counter),
		 $signed(router1_get_valueVC3));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_two_cycle4)
	$display("counter==%d, data=%h from VC4",
		 $signed(counter),
		 $signed(router1_get_valueVC4));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_two_cycle5)
	$display("counter==%d, data=%h from VC5",
		 $signed(counter),
		 $signed(router1_get_valueVC5));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_two_cycle6)
	$display("counter==%d, data=%h from VC6",
		 $signed(counter),
		 $signed(router1_get_valueVC6));
  end
  // synopsys translate_on
endmodule  // mkcheck

